{
    "collab_server" : "",
    "contents" : "# functions to transform covariates\n\n#' @name pcaTrans\n#' @rdname pcaTrans\n#'\n#' @title PCA transform a \\code{Raster*} object\n#'\n#' @description Given a matrix of point coordinates and a Raster* object of\n#'  covariates, return a \\code{Raster*} object of the same size with the layers\n#'  giving principal components from a PCA rotation based on the data values\n#'  at the coordinates.\n#'\n#' @param coords a two-column matrix or dataframe giving the location about\n#' which to carry out the PCA analysis\n#'\n#' @param covs a \\code{Raster*} object containing covariates to rotate\n#'\n#' @return a \\code{Raster*} object with the same extent, resolutiona and number\n#'  of layers as \\code{covs} but with each layer giving the location on a\n#'  different principal component axis.\n#'\n#' @family transform\n#'\n#' @export\n#' @import raster\n#'\npcaTrans <- function(coords, covs) {\n\n\n  # get covariate data at point locations\n  vals <- extract(covs, coords)\n  vals <- na.omit(vals)\n\n  # do pca analysis\n  pca <- prcomp(vals, retx = FALSE, center = TRUE, scale. = TRUE)\n\n  # find non-missing cells\n  cell_idx <- cellIdx(covs)\n\n  # extract covariate values\n  vals <- raster::extract(covs, cell_idx)\n\n  # convert to a data.frame\n  vals <- data.frame(vals)\n\n  # get PCA predictions\n  vals_trans <- predict(pca, vals)\n\n  # set new raster values\n  trans_ras <- insertRaster(raster = covs,\n                            new_vals = vals_trans,\n                            idx = cell_idx)\n  return (trans_ras)\n\n}\n\n\n\n#' @name gamTrans\n#' @rdname gamTrans\n#'\n#' @title Carry out a model-based covariate transformation using a GAM\n#'\n#' @description Define an optimal set of univariate covariate\n#'  transformations of a set of model covariates by fitting a generalised\n#'  additive model with univariate smoothers to data, and then using the\n#'  smoothers to spline-transform the covariates.\n#'  This makes use of the\\code{type = 'terms'} argument in\n#'  \\code{\\link{predict.gam}}.\n#'  This function also makes use of\n#'\n#' @param coords a two-column matrix of coordinates of records\n#'\n#' @param response an object acting as thge response object in the GAM\n#'  model (e.g. a vector of counts, or a matrix for binomial data)\n#'\n#' @param covs a \\code{Raster*} object giving the spatial covariates\n#'  for the main part of the model\n#'\n#' @param family the distribution family for the gam\n#'\n#' @param condition an optional vector of 1s and 0s of the same length as\n#'  the number of records in \\code{coords} and \\code{response} and stating\n#'  whether the record should also be modelled using covariates in\n#'  \\code{condition_covs} (1 if so and 0 if not). This enables the construction\n#'  of slightly more complex models, such as those with an explicitly modelled\n#'  observation process. This is achieved by passing \\code{condition} to the\n#'  \\code{by} argument in \\code{mgcv::s} when fitting smooths for\n#'  the condition covariates, as well as adding the condition as an intercept.\n#'\n#' @param condition_covs an optional \\code{Raster*} object giving the spatial covariates\n#'  for the conditional part of the model\n#'\n#' @param extra_terms an optional formula object (of the form \\code{~ s(x, k = 2)}\n#'  or similar which can be concatenated onto the model formula)\n#'  specifying further model components (in \\code{extra_data}) not provided in\n#'  the spatial covariates.\n#'\n#' @param extra_data an optional dataframe giving the covariates referred to in\n#'  \\code{extra_terms}\n#'\n#' @param bam whether to fit the model using \\code{mgcv::bam} (the default),\n#'  otherwise \\code{mgcv::gam} is used instead\n#'\n#' @param s_args a named list of additional arguments to pass to the smoother on\n#'   each covariate. For example, this may include the smoother type (\\code{bs})\n#'   or the basis dimension (\\code{k}). See \\code{\\link[mgcv]{s}} for the list\n#'   of available arguments.\n#'\n#' @param predict whether to transform the rasters after fitting the model.\n#'  If set to \\code{FALSE} this can enable model tweaking before the final\n#'  transformations are applied, without the computational cost of prediction\n#'\n#' @param \\dots other arguments to be passed to \\code{mgcv::bam} or\n#'  \\code{mgcv::gam}\n#'\n#' @return a three-element named list containing:\n#'  \\itemize{\n#'    \\item{model}{the fitted \\code{bam} or \\code{gam} model object}\n#'    \\item{trans}{if \\code{predict = TRUE} a \\code{Raster*} object of the\n#'     same extent, resolution and number of layers as \\code{covs}, but with\n#'     the values of each layer having been optimally spline-transformed.\n#'     Otherwise \\code{NULL}}\n#'    \\item{trans_cond}{if \\code{predict = TRUE} and \\code{condition} is not\n#'     \\code{NULL} a \\code{Raster*} object of the same extent, resolution and\n#'     number of layers as \\code{condition_covs}, but with the values of each layer\n#'     having been optimally spline-transformed. Otherwise \\code{NULL}}\n#'  }\n#'\n#' @export\n#' @import mgcv\n#' @import raster\n#'\ngamTrans <- function(coords,\n                     response,\n                     covs,\n                     family = gaussian,\n                     condition = NULL,\n                     condition_covs = NULL,\n                     extra_terms = NULL,\n                     extra_data = NULL,\n                     bam = TRUE,\n                     s_args = list(),\n                     predict = TRUE,\n                     ...) {\n  \n  # test to see if covs are passed as a rasterbrick or a list\n    # an RBrick indicates there are no temporal covariates\n    # a list indicates either a mix, or only temporal\n    # within the list RLayers are non-temporal, RBricks are temporally varying\n  if(inherits(covs,'list')) {\n    temporal = TRUE\n  } else {\n    temporal = FALSE\n  } \n  \n  # run a test to see that we have years in the extra_data if we have temporal covs\n  if(temporal & is.null(extra_data))\n    stop('You have temporally-varying covariates, but not temporally varying data. Please include in extra data argument.')\n  \n  # test we have the same number of periods in data as in all temporal covs\n  if(temporal & !is.null(extra_data)){\n    for(rb in covs) {\n      if(class(rb)==\"RasterBrick\"&dim(rb)[3]!=length(unique(extra_data$year)))\n        stop('One of your temporally-varying bricks does not have the correct number of layers. Assumes year is the temporal variable in your extra_data.')\n    }\n  }\n  \n  \n  # whether there's a conditional bit\n  cond <- !is.null(condition)\n\n  stopifnot(inherits(extra_terms, 'formula'))\n\n  # check inputs\n  stopifnot(inherits(covs, 'Raster')|inherits(covs, 'list'))\n  if (cond)\n    stopifnot(inherits(condition_covs, 'Raster'))\n\n  # add 'cond_' onto the conditional covariate names to prevent naming conflicts\n  # with the disease model\n  if (cond)\n    names(condition_covs) <- paste0('cond_', names(condition_covs))\n\n  # get covariate names\n  cov_names <- names(covs)\n  if (cond)\n    cond_names <- names(condition_covs)\n\n\n  # ~~~~~~~~~~~~~\n  # build formula\n\n  cov_terms_string <- paste(sprintf('s(%s, %s)',\n                                    cov_names,\n                                    parseArgsS(s_args)),\n                            collapse = ' + ')\n\n  cov_terms <- reformulate(cov_terms_string)\n\n  f <- response ~ 1\n  f <- f + cov_terms\n\n  # if required, add conditional terms\n  if (cond) {\n    cond_terms_string <- paste(sprintf('s(%s, %s, by = condition)',\n                                      cond_names,\n                                      parseArgsS(s_args)),\n                              collapse = ' + ')\n\n    cond_terms <- reformulate(cond_terms_string)\n\n    f <- f + cond_terms + ~ condition_intercept\n  }\n\n  # if required, add extra terms\n  if (!is.null(extra_terms))\n    f <- f + extra_terms\n\n  # assign any objects in the arguments of l into this environment\n  # so they can be accessed by gam/bam\n  if (length(s_args) > 0) {\n    for (i in 1:length(s_args))\n      assign(names(s_args)[i], s_args[[i]])\n  }\n\n  # ~~~~~~~~~~~~~\n  # get training data\n\n  # extraction for temporally varying and non-temporally varing covariates is slightly different\n  if(temporal){\n    # split apart temporally varying and non temporally varying covariates\n    nT_covs=T_covs=list()\n    for(c in names(covs)){\n      if(class(covs[[c]])==\"RasterLayer\")\n        nT_covs[[c]]=covs[[c]]\n      if(class(covs[[c]])==\"RasterBrick\")\n        T_covs[[c]]=covs[[c]]\n    }\n    \n    # initiate \n    if (!is.null(extra_data)){\n      data <- extra_data\n    } else {\n      stop('you have temporal covariates with no year extra data terms.')\n    }\n    \n    \n    # begin data with nontemporally varying because that is easy\n    if(length(nT_covs)>0){\n      nT_covs=brick(nT_covs)\n      crs(nT_covs)=\"+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0\"\n      data <- data.frame(cbind(data,extract(nT_covs, coords)))\n    }\n    \n    \n    # Note, we expect rasterbricks to go from earliest to latest period order, it will match with watch we get in extra_data to do this\n    periods=sort(unique(data$year))\n    tnames=c()\n    for(n in names(T_covs)){\n      names(T_covs[[n]])=paste0(n,periods)\n      tnames=c(tnames,names(T_covs[[n]]))\n      data <- data.frame(cbind(data,extract(T_covs[[n]], coords)))\n    }\n    \n    # match years of time varying covariates and data points, then clean up the data frame\n    # assumes a 4 year time period (years, in most cases 2000,2005,2010,2015)\n    for(n in tnames)\n      data[,n][data$year!= as.numeric(substr(n,nchar(n)-3,nchar(n)))]=NA\n    for(n in names(T_covs))\n      data[,n]=rowSums(data[,paste0(n,periods)],na.rm=T)\n    \n    data=data[,!names(data) %in% tnames]\n    \n    # save all covs in a brick, will need them later\n    covs<-brick(covs)\n  }\n  \n  \n  \n  # extract covariates if have no temporally varying\n  if(!temporal) {\n    \n    data <- data.frame(extract(covs, coords))\n\n    if (!is.null(extra_data)){\n      data <- extra_data\n    } \n  } \n    \n  \n  # optionally combine this with the conditional and extra data\n  if (cond)\n    data <- cbind(data,\n                  data.frame(extract(condition_covs,\n                                     coords)),\n                  condition_intercept = condition,\n                  condition)\n\n\n  \n  \n  # find any missing values and remove corresponding rows\n  rem_idx <- badRows(data)\n  data <- data[!rem_idx, ]\n\n  if (is.vector(response)) {\n    response <- response[!rem_idx]\n  } else {\n    response <- response[!rem_idx, ]\n  }\n\n  \n  \n  \n  # fit the model\n  if (bam) {\n    m <- mgcv::bam(f, data = data, family = family, ...)\n  } else {\n    m <- mgcv::gam(f, data = data, family = family, ...)\n  }\n\n  \n  \n  # ~~~~~~~~~~\n  # optionally apply transformations\n\n  if (predict) {\n\n    # find index for non-missing cells\n    cell_idx <- cellIdx(covs)\n      \n      \n      \n    # transform the main covariates\n\n    # extract covariate values\n    vals <- raster::extract(covs, cell_idx)\n\n    \n    ### !!!! STOPPING POINT!\n    \n    # convert to a data.frame\n    vals <- data.frame(vals)\n\n    # add on the extra data\n    vals <- cbind(vals, extra_data[rep(1, nrow(vals)), , drop = FALSE])\n\n    # optionally add on dummy data for the condition intercept and variables\n    if (cond) {\n      cond_data <- data.frame(matrix(0,\n                                     nrow = 1,\n                                     ncol = length(cond_names)))\n      names(cond_data) <- cond_names\n      vals <- cbind(vals,\n                    condition = 0,\n                    condition_intercept = 0,\n                    cond_data)\n    }\n\n    # get the transformations of these values\n    vals_trans <- predict(m,\n                          newdata = vals,\n                          type = 'terms')\n\n    # find any condition terms\n    cond_terms_idx <- grep('):condition$', colnames(vals_trans))\n\n    # remove the condition ones and the condition index\n    if (length(cond_terms_idx) > 0) {\n      vals_trans <- vals_trans[, -cond_terms_idx]\n    }\n    vals_trans <- vals_trans[, !(colnames(vals_trans) %in% c('condition', 'condition_intercept'))]\n\n    # format the names\n    colnames(vals_trans) <- gsub(')', '', colnames(vals_trans))\n    colnames(vals_trans) <- gsub('^s\\\\(', '', colnames(vals_trans))\n\n    # keep only the names that are in the raster\n      # gets rid of year and age bin\n    vals_trans <- vals_trans[, colnames(vals_trans) %in% cov_names]\n\n    # set new raster values\n        # !! THIS will need editing for temporals to run.\n    trans_ras <- insertRaster(raster = covs,\n                              new_vals = vals_trans,\n                              idx = cell_idx)\n\n    # optionally apply the transformation to the conditional terms\n\n    if (cond) {\n\n      # remove the previous variables\n      rm(vals, vals_trans)\n\n      # extract covariate values\n      vals <- raster::extract(condition_covs, cell_idx)\n\n      # convert to a data.frame\n      vals <- data.frame(vals)\n\n      # add on the extra data\n      vals <- cbind(vals, extra_data[rep(1, nrow(vals)), ])\n\n      # add on dummy data for the main variables\n      main_data <- data.frame(matrix(0,\n                                     nrow = 1,\n                                     ncol = length(cov_names)))\n\n      names(main_data) <- cov_names\n\n      vals <- cbind(vals,\n                    condition = 1,\n                    condition_intercept = 0,\n                    main_data)\n\n      # get the transformations of these values\n      vals_trans <- predict(m,\n                            newdata = vals,\n                            type = 'terms')\n\n      # keep only the condition ones\n      vals_trans <- vals_trans[, grep('):condition$', colnames(vals_trans))]\n\n      # format the names\n      colnames(vals_trans) <- gsub('):condition$', '', colnames(vals_trans))\n      colnames(vals_trans) <- gsub('^s\\\\(', '', colnames(vals_trans))\n\n      # keep only the names that are in the raster\n      vals_trans <- vals_trans[, colnames(vals_trans) %in% cond_names]\n\n      # remove the `cond_` bit\n      colnames(vals_trans) <- gsub('^cond_', '', colnames(vals_trans))\n\n      # set new raster values\n      trans_cond_ras <- insertRaster(raster = condition_covs,\n                                     new_vals = vals_trans,\n                                     idx = cell_idx)\n\n    } else {\n      trans_cond_ras <- NULL\n    }\n\n  } else {\n    # if not poredicting, set these to NULL\n    trans_ras <- trans_cond_ras <- NULL\n\n  }\n\n  # return the three components\n  return (list(model = m,\n               trans = trans_ras,\n               trans_cond = trans_cond_ras))\n\n}\n\n\naddQuotes <- function (x) {\n  # If x is a character string, add (escaped) quotation marks\n  if (is.character(x)) {\n    x <- sprintf('\\\"%s\\\"', x)\n  }\n  return (x)\n}\n\nparseArgsS <- function(l) {\n  # parse a list of additional arguments to smoothers in gamTrans\n  stopifnot(is.list(l))\n  l_string <- paste(names(l),\n                    lapply(l, addQuotes),\n                    sep = ' = ',\n                    collapse = ', ')\n  return (l_string)\n}\n\n",
    "created" : 1460664910524.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "688464120",
    "id" : "9265DC5A",
    "lastKnownWriteTime" : 1460678437,
    "last_content_update" : 1460678437443,
    "path" : "C:/Users/royburst/Google Drive/seegMBG/R/transform_functions.R",
    "project_path" : "R/transform_functions.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}